<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Algorith and DSA</title>
</head>
<body>

    <script>

        // BIG O NOTATION
        // ---------------------------------------------------------------------------------

        // time complexity - calculate how much time taken to execute a piece of code.
        // ---------------------------------------------------------------------------------------------
        // // // EX - 1

        // function addUpTo(n) {
        //     let total = 0;
        //     for (let i = 1; i <= n; i++) {
        //         total += i;
        //     }
        //     return total;
        // }
        // // console.log(addUpTo(1000000000));
        // // ANS - O(n) Notation - n time operator's are added and multiplied

        // // // EX - 2

        // function addUpTo(n) {
        //     return n * (n + 1) / 2;
        // }
        // // console.log(addUpTo(1000000000));
        // // ANS - O(1) Notation - only 3 operator and constant operator

        // // // EX - 3 - check run timimg

        // let t1 = performance.now();
        // addUpTo(1000000000);
        // let t2 = performance.now();
        // console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`)

        // // NOTES - IMPORTANT

        // // O(2n) -> O(n)
        // // O(500) -> O(1)
        // // O((13n^2) -> O(n^2)
        // // O(n + 10) -> O(n)
        // // O(1000n + 50) -> O(n)
        // // O((n^2   + 5n + 8 ) -> O(n^2)

        // Arithmetic operations are constant
        // Variable assignment is constant
        // Accessing elements in an array (by index) or object (by key) is constant
        // In a loop, the the complexity is the length of the loop times the complexity of whatever happens inside of the loop

        // // // EX - 4
        // function logAtLeast5(n) {
        //     for (var i = 1; i <= Math.max(5, n); i++) {
        //         console.log(i);
        //     }
        // }
        // logAtLeast5(1);
        // // // ANS - O(n) takes maximum number 


        // // // EX - 5
        // function logAtMost5(n) {
        //     for (var i = 1; i <= Math.min(5, n); i++) {
        //         console.log(i);
        //     }
        // }
        // logAtMost5(100)
        // // // ANS - O(1) takes minimum number
        

        // // space complexity - calculate how much memory/space taken to execute a piece of code.
        // ---------------------------------------------------------------------------------------------

        // // NOTES - IMPORTANT
        // Most primitives (booleans, numbers, undefined, null) are constant space
        // Strings require O(n) space (where n is the string length)
        // Reference types are generally O( n), where n is the length (for arrays) or the number of keys (for objects)

        // // // EX - 6

        // function sum(arr) {
        //     let total = 0;
        //     for (let i = 0; i < arr.length; i++) {
        //         total += arr[i];
        //     }
        //     return total;
        // }
        // console.log(sum(10));
        // // There are 2 variable. so data hold by only 2 variables. - O(1) space!

        // // // EX - 7

        // function double(arr) {
        //     let newArr = [];
        //     for (let i = 0; i < arr.length; i++) {
        //         newArr.push(2 * arr[i]);
        //     }
        //     return newArr;
        // }
        // console.log(double([1,2,3]));
        // // There are 2 variable one is constant another is an array.
        // // if any array or object exist then space complexity is O(n) space!


        // // NOTES - IMPORTANT
        // To analyze the performance of an algorithm, we use Big O Notation
        // Big O Notation can give us a high level understanding of the time or space complexity of an algorithm
        // Big O Notation doesn't care about precision, only about general trends (linear? quadratic? constant?)
        // The time or space complexity (as measured by Big O) depends only on the algorithm, not the hardware used to run the algorithm
        // Big O Notation is everywhere, so get lots of practice!


        // // Section 3: Analyzing Performance of Arrays, Objects, inbuilt function
        // // ----------------------------------------------------------------------------------

        // // // EX - 8

        // let instructor = {
        //     firstName: "Kelly",
        //     isInstructor: true,
        //     favoriteNumbers: [1,2,3,4]
        // }
        // // console.log(Object.keys(instructor))

        // // NOTES - IMPORTANT

        // When to use objects
        // When you don't need order
        // When you need fast access / insertion and removal

        // Insertion -   O(1)
        // Removal -   O(1)
        // Searching -   O(N)
        // Access -   O(1)
        // Object.keys -   O(N)
        // Object.values -   O(N)
        // Object.entries -   O(N)
        // hasOwnProperty -   O(1)

        // // // EX - 9
        // let names = ["Michael", "Melissa", "Andrea"];
        // let values = [true, {}, [], 2, "awesome"];

        // // NOTES - IMPORTANT

        // WHEN TO USE ARRAYS
        // When you need order
        // When you need fast access / insertion and removal (sort of....)

        // Insertion -   It depends....
        // Removal -   It depends....
        // Searching -   O(N)
        // Access -   O(1)

        // push -   O(1)
        // pop -   O(1)
        // shift -   O(N)
        // unshift -   O(N)
        // concat -   O(N)
        // slice -   O(N)
        // splice -   O(N)
        // sort -   O(N * log N)
        // forEach/map/filter/reduce/etc. -   O(N)

        // Limitations of Arrays - Inserting at the beginning is not as easy as we might think! There are more efficient data structures for that!

        
        // // Section 4: Problem Solving Approach
        // // ----------------------------------------------------------------------------------

        // // NOTES - IMPORTANT

        // WHAT IS AN ALGORITHM?
        // A process or set of steps to accomplish a certain task in minimal time.

        // How to solve the questions or problems?
        // UNDERSTAND THE PROBLEM
        // Can I restate the problem in my own words?
        // What are the inputs that go into the problem?
        // What are the outputs that should come from the solution to the problem?
        // Can the outputs be determined from the inputs? In other words, do I have enough information to solve the problem? (You may not be able to answer this question until you set about solving the problem. That's okay; it's still worth considering the question at this early stage.)
        // How should I label the important pieces of data that are a part of the problem?

        // // // EX - 10
        // // Write a function which takes any two numbers and returns their sum. 

        // function addTwoNumber(str1, str2){ 
        //     let num1 = str1.toString().replace(',', '');
        //     let num2 = str2.toString().replace(',', '');
        //     return parseFloat(Number(num1)+Number(num2)).toFixed(2);
        // }

        // console.log(addTwoNumber(100.10,'200.30'));
        // console.log(addTwoNumber('100.10','200.30'));
        // console.log(addTwoNumber(100.10,200.30));

        
        // // // EX - 11
        // // Write a function which takes in a string and returns counts of each character in the string except symbol and space and letter will not be dupliacte.
        
        // // Answer - 1
        // function charCount(str){
        //     let strObj = {};
        //     for(let i = 0; i<str.length; i++){
        //         var char = str[i].toLowerCase();
        //         if(/[a-z0-9]/.test(char)){
        //             if(strObj[char] > 0){
        //                 strObj[char]++;
        //             }else{
        //                 strObj[char] =  1;
        //             }  
        //         }
        //     }
        //     return strObj;
        // }

        // // Answer - 2
        // function charCount(str){
        //     let strObj = {};
        //     for(var char of str){
        //         char = char.toLowerCase();
        //         if(isAlphaNumeric(char)){
        //             strObj[char] = ++strObj[char] || 1;
        //         }
        //     }
        //     return strObj;
        // }
        // function isAlphaNumeric(char){
        //     var code = char.charCodeAt(0);
        //     if (!(code > 47 && code < 58) &&
        //         !(code > 64 && code < 91) &&
        //         !(code > 96 && code < 123)){
        //         return false;
        //     }
        //     return true;
        // }

        // console.log(charCount('Hii Anshuman !!!'));
        // let t1 = performance.now();
        // charCount('Hii Anshuman !!!')
        // let t2 = performance.now();
        // console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`)
        
        
        // // // EX - 12
        // // Write a function called same, which accepts two arrays. The function should return true if every value in the array has it's corresponding value squared in the second array. The frequency of values must be the same.

        // // Inputs - 
        // same([1,2,3], [4,1,9]) // true
        // same([1,2,3], [1,9]) // false
        // same([1,2,1], [4,4,1]) // false (must be same frequency)

        // // Answer - 1
        // function same(arr1, arr2){
        //     if(arr1.length != arr2.length){
        //         return false;
        //     }
        //     for(let i = 0; i < arr1.length; i++){ // O(n) bcz of for loop
        //         let correctIndex = arr2.indexOf(arr1[i] ** 2) // O(n) bcz of indexOf // return the index value. of an array.
        //         if(correctIndex === -1) {
        //             return false;
        //         }
        //         arr2.splice(correctIndex,1) // if index exist then remove that index value and return new array.
        //     }
        //     return true;
        // }

        // // Answer - 2
        // function same(arr1, arr2){
        //     if(arr1.length !== arr2.length){
        //         return false;
        //     }
        //     let frequencyCounter1 = {}
        //     let frequencyCounter2 = {}
        //     for(let val of arr1){
        //         frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1
        //     }
        //     for(let val of arr2){
        //         frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1        
        //     }

        //     // console.log(frequencyCounter1);
        //     // console.log(frequencyCounter2);
        //     for(let key in frequencyCounter1){

        //         // console.log(key);
        //         if(!(key ** 2 in frequencyCounter2)){
        //             return false
        //         }

        //         // console.log(frequencyCounter2[key ** 2]);
        //         if(frequencyCounter2[key ** 2] !== frequencyCounter1[key]){
        //             return false
        //         }
        //     }
        //     return true
        // }

        // console.log(same([1,2,3, 2], [4,1,9, 4]));


        // // // EX - 13
        // // Given two strings, write a function to determine if the second string is an anagram of the first. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema, formed from iceman.

        // // Inputs - 
        // validAnagram('', '') // true
        // validAnagram('aaz', 'zza') // false
        // validAnagram('anagram', 'nagaram') // true
        // validAnagram("rat","car") // false) // false
        // validAnagram('awesome', 'awesom') // false
        // validAnagram('amanaplanacanalpanama', 'acanalmanplanpamana') // false
        // validAnagram('qwerty', 'qeywrt') // true
        // validAnagram('texttwisttime', 'timetwisttext') // true

        // // Answer - 1
        // function validAnagram(str1, str2){
        //     if(str1.length !== str2.length){return false}
        //     let frequencyCounter1 = {}
        //     let frequencyCounter2 = {}
        //     for(var char of str1){
        //         frequencyCounter1[char] = (frequencyCounter1[char] || 0) + 1
        //     }
        //     for(var char of str2){
        //         frequencyCounter2[char] = (frequencyCounter2[char] || 0) + 1        
        //     }
        //     // console.log(frequencyCounter1);
        //     // console.log(frequencyCounter2);
        //     for(var key in frequencyCounter1){
        //         // console.log(frequencyCounter1[key]);
        //         if(!(key in frequencyCounter2)){
        //             return false
        //         }else{
        //             if(frequencyCounter1[key] != frequencyCounter2[key]){
        //                 return false
        //             }
        //         }
        //     }
        //     for(var key in frequencyCounter2){
        //         // console.log(frequencyCounter1[key]);
        //         if(!(key in frequencyCounter1)){
        //             return false
        //         }else{
        //             if(frequencyCounter2[key] != frequencyCounter1[key]){
        //                 return false
        //             }
        //         }
        //     }
        //     return true;
        // }

        // // Answer - 2
        // function validAnagram(first, second) {
        //     if (first.length !== second.length) {
        //         return false;
        //     }
        //     const lookup = {};
        //     for (let i = 0; i < first.length; i++) {
        //         let letter = first[i];
        //         // if letter exists, increment, otherwise set to 1
        //         lookup[letter] ? lookup[letter] += 1 : lookup[letter] = 1;
        //     }
        //     console.log(lookup)
        //     for (let i = 0; i < second.length; i++) {
        //         let letter = second[i];
        //         // can't find letter or letter is zero then it's not an anagram
        //         if (!lookup[letter]) {
        //             return false;
        //         } else {
        //             lookup[letter] -= 1;
        //         }
        //     }
        //     return true;
        // }

        // console.log(validAnagram('texttwisttime', 'timetwisttext'))


        // // // EX - 14
        // // Write a function called sumZero which accepts a sorted array of integers. The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist

        // // Inputs - 
        // sumZero([-3,-2,-1,0,1,2,3]) // [-3,3] 
        // sumZero([-2,0,1,3]) // undefined
        // sumZero([1,2,3]) // undefined

        // // Answer - 1 - NAIVE SOLUTION
        // function sumZero(arr){
        //     for(let i=0; i<arr.length; i++){
        //         for(let j = i+1; j<arr.length; j++){
        //             if(arr[i] + arr[j] === 0){
        //                 return [arr[i], arr[j]];
        //             }
        //         }
        //     }
        // }

        // // Time Complexity - O(N^2)
        // // Space Complexity - O(1)

        // // Answer - 2
        // function sumZero(arr){
        //     let left = 0;
        //     let right = arr.length - 1;
            
        //     while(left < right){
        //         let sum = arr[left] + arr[right];

        //         if(sum === 0){
        //             return [arr[left], arr[right]];
        //         }else if(sum > 0){
        //             right--;
        //         }else{
        //             left++;
        //         }
        //     }
        // }

        // // Time Complexity - Log(N)
        // // Space Complexity - O(1)

        // console.log(sumZero([-3,-2,-1,0,1,2,3]));


        // // // EX - 15
        // // Implement a function called countUniqueValues, which accepts a sorted array, and counts the unique values in the array. There can be negative numbers in the array, but it will always be sorted.

        // // Inputs - 
        // countUniqueValues([1,1,1,1,1,2]) // 2
        // countUniqueValues([1,2,3,4,4,4,7,7,12,12,13]) // 7
        // countUniqueValues([]) // 0
        // countUniqueValues([-2,-1,-1,0,1]) // 4

        // // Answer - 1
        // function countUniqueValues(arr){
        //     let count = 0;
        //     // if(arr.length === 0){
        //     //     return count;
        //     // }
        //     // or
        //     if(arr.length === 0) return count;
        //     let countUniqueobj = {};
        //     for(let val of arr){
        //         if(countUniqueobj[val] > 0){
        //             countUniqueobj[val]++;
        //         }else{
        //             countUniqueobj[val] = 1;
        //         }
        //     }
        //     // for(let key in countUniqueobj) {
        //     //     // increase the count
        //     //     ++count;
        //     // }
        //     // or
        //     count = Object.keys(countUniqueobj).length; // object count
        //     return count;
        // }

        // // Time Complexity - O(N)
        // // Space Complexity - O(N)

        // // Answer - 2
        // function countUniqueValues(arr){
        //     if(arr.length === 0) return 0;
        //     var i = 0;
        //     for(var j = 1; j < arr.length; j++){
        //         if(arr[i] !== arr[j]){
        //             i++;
        //             arr[i] = arr[j]
        //         }
        //     }
        //     return i + 1;
        // }

        // // Time Complexity - O(N)
        // // Space Complexity - O(N)

        // console.log(countUniqueValues([1,2,3,4,4,4,7,7,12,12,13]));


        // // // EX - 16
        // // Write a function called maxSubarraySum which accepts an array of integers and a number called n. The function should calculate the maximum sum of n consecutive elements in the array.

        // // NOTES - IMPORTANT

        // SLIDING WINDOW - This pattern involves creating a window which can either be an array or number from one position to another 
        // Depending on a certain condition, the window either increases or closes (and a new window is created) 
        // Very useful for keeping track of a subset of data in an array/string etc.

        // // Inputs - 
        // maxSubarraySum([1,2,5,2,8,1,5],2) // 10
        // maxSubarraySum([1,2,5,2,8,1,5],4) // 17
        // maxSubarraySum([4,2,1,6],1) // 6
        // maxSubarraySum([4,2,1,6,2],4) // 13
        // maxSubarraySum([],4) // null

        // // Answer - 1
        // function maxSubarraySum(arr, num){
        //     if(num > arr.length){return null}
        //     if(arr.length === 0){return null}
        //     var max = -Infinity;
        //     for(let i = 0; i < arr.length - num + 1; i++){
        //         temp = 0;
        //         for(let j = 0; j < num; j++){
        //             temp += arr[i+j];
        //         }
        //         if(temp > max){
        //             max = temp;
        //         }
        //     }
        //     return max;
        // }

        // // Time Complexity - O(n^2)
        // // Space Complexity - O(1)

        // // Answer - 2
        // function maxSubarraySum(arr, num){
        //     if(num > arr.length) return null

        //     let maxSum = 0;
        //     let tempSum = 0;
        //     for(let i = 0; i < num; i++){
        //         tempSum += arr[i];
        //     }
        //     maxSum = tempSum;
        //     for(let i = num; i < arr.length; i++){
        //         tempSum = tempSum + arr[i] - arr[i-num];
        //         maxSum = Math.max(tempSum, maxSum);
        //     }
        //     return maxSum;
        // }

        // // Time Complexity - O(N)
        // // Space Complexity - O(1)

        // console.log(maxSubarraySum([1,2,5,2,8,1,5],4));


        // // // EX - 17
        // // Given a sorted array of integers, write a function called search, that accepts a value and returns the index where the value passed to the function is located. If the value is not found, return -1 

        // // NOTES - IMPORTANT

        // Divide and Conquer - This pattern involves dividing a data set into smaller chunks and then repeating a process with a subset of data.
        // This pattern can tremendously decrease time complexity

        // // Inputs - 
        // search([1,2,3,4,5,6],4) // 3
        // search([1,2,3,4,5,6],6) // 5
        // search([1,2,3,4,5,6],11) // -1

        // // Answer - 1
        // function search(arr, num){
        //     return arr.indexOf(num);
        // }

        // // Time Complexity - O(N)
        // // Space Complexity - O(1)

        // // Answer - 2
        // function search(arr, num){
        //     for(let i = 0; i < arr.length; i++){
        //         if(num == arr[i]){
        //             return i;
        //         }
        //     }
        //     return -1;
        // }

        // // Time Complexity - O(N)
        // // Space Complexity - O(1)

        // // Answer - 3
        // function search(arr, num){
        //     let min = 0;
        //     let max = arr.length - 1;

        //     while(min < max){
        //         let middle = Math.floor((min+max)/2);
        //         let currentElement = array[middle];

        //         if (array[middle] < num) {
        //             min = middle + 1;
        //         }
        //         else if (array[middle] > num) {
        //             max = middle - 1;
        //         }
        //         else {
        //             return middle;
        //         }
        //     }
        // }

        // // Time Complexity - Log(N)

        // console.log(search([1,2,3,4,5,6],6));


        // // // EX - 18
        // // Frequency Counter - sameFrequency - Write a function called sameFrequency. Given two positive integers, find out if the two numbers have the same frequency of digits.

        // // Inputs - 
        // sameFrequency(182,281) // true
        // sameFrequency(34,14) // false
        // sameFrequency(3589578, 5879385) // true
        // sameFrequency(22,222) // false

        // // Answer - 1
        // function sameFrequency(num1,num2){
        //     let str1 = num1.toString();
        //     let str2 = num2.toString();

        //     // if(str1.length !== str2.length){
        //     //     return false;
        //     // }
        //     // or
        //     if(str1.length !== str2.length) return false;
            
        //     let obj1 = {};
        //     // for(let i = 0; i < str1.length; i++){
        //     //     var count1 = str1[i];
        //     //     if(obj1[count1] > 0){
        //     //         obj1[count1]++;
        //     //     }
        //     //     else{
        //     //         obj1[count1] = 1;
        //     //     }
        //     // }
        //     // or
        //     for(let i = 0; i < str1.length; i++){
        //         obj1[str1[i]] = (obj1[str1[i]] || 0) + 1;
        //     }

        //     let obj2 = {};
        //     // for(let i = 0; i < str2.length; i++){
        //     //     var count2 = str2[i];
        //     //     if(obj2[count2] > 0){
        //     //         obj2[count2]++;
        //     //     }
        //     //     else{
        //     //         obj2[count2] = 1;
        //     //     }
        //     // }
        //     // or
        //     for(let i = 0; i < str2.length; i++){
        //         obj2[str2[i]] = (obj2[str2[i]] || 0) + 1;
        //     }
        //     // for(var key in obj1){
        //     //     if(!(key in obj2)){
        //     //         return false
        //     //     }else{
        //     //         if(obj1[key] != obj2[key]){
        //     //             return false
        //     //         }
        //     //     }
        //     // }
        //     // for(var key in obj2){
        //     //     if(!(key in obj1)){
        //     //         return false
        //     //     }else{
        //     //         if(obj2[key] != obj1[key]){
        //     //             return false
        //     //         }
        //     //     }
        //     // }
        //     // or
        //     for(let key in obj1){
        //         console.log(obj2[key]);
        //         if(obj1[key] !== obj2[key]) return false;
        //     }
        //     return true;
        // }

        // console.log(sameFrequency(1882,2717));

        // // // EX - 19
        // // Implement a function called, areThereDuplicates which accepts a variable number of arguments, and checks whether there are any duplicates among the arguments passed in.  You can solve this using the frequency counter pattern OR the multiple pointers pattern.

        // // Inputs -
        // areThereDuplicates(1, 2, 3) // false
        // areThereDuplicates(1, 2, 2) // true 
        // areThereDuplicates('a', 'b', 'c', 'a') // true 

        // // Answer - 1
        // function areThereDuplicates() {
        //     let countObj = {};
        //     // for(let i = 0; i < arguments.length; i++){
        //     //     countObj[arguments[i]] = (countObj[arguments[i]] || 0) + 1;
        //     // }
        //     // or
        //     for(let val in arguments){
        //         countObj[arguments[val]] = (countObj[arguments[val]] || 0) + 1
        //     }
        //     for(let key in countObj){
        //         if(countObj[key] > 1) return true;
        //     }
        //     return false;
        // }

        // // Answer - 2
        // function areThereDuplicates(...args) {
        //     // Two pointers
        //     args.sort((a,b) => a > b);
        //     let start = 0;
        //     let next = 1;
        //     while(next < args.length){
        //         if(args[start] === args[next]){
        //             return true
        //         }
        //         start++
        //         next++
        //     }
        //     return false
        // }

        // // Answer - 3
        // function areThereDuplicates(){
        //     return new Set(arguments).size !== arguments.length;
        // }

        // Restrictions:
        //     Time - O(n)
        //     Space - O(n)
        // Bonus:
        //     Time - O(n log n)
        //     Space - O(1)

        // console.log(areThereDuplicates(1, 2, 3));


        // // // EX - 20
        // // Multiple Pointers - averagePair - Write a function called averagePair. Given a sorted array of integers and a target average, determine if there is a pair of values in the array where the average of the pair equals the target average. There may be more than one pair that matches the average target.

        // // Inputs -
        // averagePair([1,2,3],2.5) // true
        // averagePair([1,3,3,5,6,7,10,12,19],8) // true
        // averagePair([-1,0,3,4,5,6], 4.1) // false
        // averagePair([],4) // false

        // // Answer - 1
        // function averagePair(arr, num){
        //     if(arr.length === 0) return false;
        //     let left = 0;
        //     let right = arr.length - 1;

        //     while(left < right){
        //         // console.log((arr[left]+arr[right])/2);

        //         if((arr[left]+arr[right])/2 === num){
        //             return true
        //         }else if((arr[left]+arr[right])/2 < num){
        //             left++;
        //         }else{
        //             right--;
        //         }
        //     }

        //     return false;
        // }

        // // Time - Log(N)
        // // Space - O(1)

        // console.log(averagePair([1,3,3,5,6,7,10,12,19], 8));


        // // // EX - 21
        // // Multiple Pointers - averagePair - Write a function called averagePair. Given a sorted array of integers and a target average, determine if there is a pair of values in the array where the average of the pair equals the target average. There may be more than one pair that matches the average target.

        // // Inputs -
        // averagePair([1,2,3],2.5) // true
        // averagePair([1,3,3,5,6,7,10,12,19],8) // true
        // averagePair([-1,0,3,4,5,6], 4.1) // false
        // averagePair([],4) // false

        // // Answer - 1
        // function averagePair(arr, num){
        //     if(arr.length === 0) return false;
        //     let left = 0;
        //     let right = arr.length - 1;

        //     while(left < right){
        //         // console.log((arr[left]+arr[right])/2);

        //         if((arr[left]+arr[right])/2 === num){
        //             return true
        //         }else if((arr[left]+arr[right])/2 < num){
        //             left++;
        //         }else{
        //             right--;
        //         }
        //     }

        //     return false;
        // }

        // // Time - Log(N)
        // // Space - O(1)

        // console.log(averagePair([1,3,3,5,6,7,10,12,19], 8));


        // // // EX - 22
        // // Multiple Pointers - isSubsequence - Write a function called isSubsequence which takes in two strings and checks whether the characters in the first string form a subsequence of the characters in the second string. In other words, the function should check whether the characters in the first string appear somewhere in the second string, without their order changing.

        // // Inputs -
        // isSubsequence('hello', 'hello world'); // true
        // isSubsequence('sing', 'sting'); // true
        // isSubsequence('abc', 'abracadabra'); // true
        // isSubsequence('abc', 'acb'); // false (order matters)

        // // Answer - 1
        // function isSubsequence(str1, str2){
        //     if(str1.length === 0) return false;
        //     if(str2.length === 0) return false;

        //     left = 0; 
        //     right = 0;
        //     while(right < str2.length){
        //         // console.log(left);
        //         // console.log(right);
        //         if(str2[right] === str1[left]) left++;
        //         if(left === str1.length){
        //             return true;
        //         }else{
        //             right++;
        //         }
        //     }
        //     return false
        // }

        // // Time Complexity - O(N + M)
        // // Space Complexity - O(1)

        // console.log(isSubsequence('sing', 'sting'));


        // // // EX - 23
        // // Sliding Window - maxSubarraySum - Given an array of integers and a number, write a function called maxSubarraySum, which finds the maximum sum of a subarray with the length of the number passed to the function.

        // Note that a subarray must consist of consecutive elements from the original array. In the first example below, [100, 200, 300] is a subarray of the original array, but [100, 300] is not.

        // // Inputs -
        // maxSubarraySum([100,200,300,400], 2) // 700
        // maxSubarraySum([1,4,2,10,23,3,1,0,20], 4)  // 39 
        // maxSubarraySum([-3,4,0,-2,6,-1], 2) // 5
        // maxSubarraySum([3,-2,7,-4,1,-1,4,-2,1],2) // 5
        // maxSubarraySum([2,3], 3) // null

        // // Answer - 1
        // function maxSubarraySum(arr, num){
        //     if(num > arr.length) return null;

        //     var tempSum = 0;
        //     var maxSum = 0;

        //    for(let i = 0; i < num; i++){
        //     tempSum += arr[i];
        //    }
        //    maxSum = tempSum;

        //    for(let j = num; j < arr.length; j++){
        //     tempSum = tempSum + arr[j] - arr[j - num];
        //     maxSum = Math.max(tempSum, maxSum);
        //    }
        //    return maxSum;
        // }

        // // Time Complexity -  O(N)
        // // Space Complexity - O(1)

        // console.log(maxSubarraySum([-3,4,0,-2,6,-1], 2));


        // // // EX - 24
        // // Sliding Window - minSubArrayLen - Write a function called minSubArrayLen which accepts two parameters - an array of positive integers and a positive integer.

        // This function should return the minimal length of a contiguous subarray of which the sum is greater than or equal to the integer passed to the function. If there isn't one, return 0 instead.

        // // Inputs -
        // minSubArrayLen([2,3,1,2,4,3], 7) // 2 -> because [4,3] is the smallest subarray
        // minSubArrayLen([2,1,6,5,4], 9) // 2 -> because [5,4] is the smallest subarray
        // minSubArrayLen([3,1,7,11,2,9,8,21,62,33,19], 52) // 1 -> because [62] is greater than 52
        // minSubArrayLen([1,4,16,22,5,7,8,9,10],39) // 3
        // minSubArrayLen([1,4,16,22,5,7,8,9,10],55) // 5
        // minSubArrayLen([4, 3, 3, 8, 1, 2, 3], 11) // 2
        // minSubArrayLen([1,4,16,22,5,7,8,9,10],95) // 0

        // // Answer - 1
        // function minSubArrayLen(arr, sum) {
        //     let total = 0;
        //     let start = 0;
        //     let end = 0;
        //     let minLen = Infinity;
            
        //     while (start < arr.length) {
        //         // if current window doesn't add up to the given sum then 
        //             // move the window to right
        //         if(total < sum && end < arr.length){
        //             total += arr[end];
        //             end++;
        //         }
        //         // if current window adds up to at least the sum given then
        //             // we can shrink the window 
        //         else if(total >= sum){
        //             minLen = Math.min(minLen, end-start);
        //             total -= arr[start];
        //             start++;
        //         } 
        //         // current total less than required total but we reach the end, need this or else we'll be in an infinite loop 
        //         else {
        //             break;
        //         }
        //     }
            
        //     return minLen === Infinity ? 0 : minLen;
        // }

        // // Time Complexity -  O(N)
        // // Space Complexity - O(1)

        // console.log(minSubArrayLen([2,3,1,2,4,3], 7));


        // // Recursion - A process (a function in our case) that calls itself
        
        // // NOTES - IMPORTANT

        // // How recursive functions work - Invoke the same function with a different input until you reach your base case!
        // // Base Case - The condition when the recursion ends.

        // // // EX - 25
        // function countDown(num){
        //     if(num <= 0){
        //         console.log("All Done");
        //         return;
        //     }
        //     console.log(num);
        //     num--;
        //     countDown(num);
        // }
        // countDown(6);
        //  ANS - 6,5,4,3,2,1,All Done

        // function sumRange(num){
        //     if(num === 1) return 1; 
        //     return num + sumRange(num-1);
        // }
        // console.log(sumRange(5))
        // ANS  - 5+4+3+2+1

        // function factorial(num){
        //     let total = 1;
        //     for(let i = num; i > 1; i--){
        //         total *= i;
        //     }
        //     return total;
        // }

        // function factorial(num){
        //    if(num < 0) return 0;
        //    if(num <= 1) return 1;
        //    return num * factorial(num - 1);
        // }

        // console.log(factorial(5));


        // No base case
        // Forgetting to return or returning the wrong thing!
        // Stack overflow! 
        // function factorial(num){
        //     if(num === 1) return 1;
        //     return num * factorial(num);
        // }
        // function factorial(num){
        //     if(num === 1) console.log(1) ;
        //     return num * factorial(num-1);
        // }

        // // HELPER METHOD RECURSION EXAMPLE
        // function outer(input){
        //     var outerScopedVariable = []
        //     function helper(helperInput){
        //         // modify the outerScopedVariable
        //         helper(helperInput--)
        //     }
        //     helper(input)
        //     return outerScopedVariable;
        // }


        // // Let's try to collect all of the odd values in an array 
        // Use Helper function
        // // // EX - 26
        // function collectOddValues(arr){
        //     let result = [];
        //     function helper(arrayInput){
        //         if(arrayInput.length === 0){
        //             return;
        //         }   
        //         if((arrayInput[0] % 2) !== 0){
        //             result.push(arrayInput[0])
        //         }
        //         helper(arrayInput.slice(1));
        //     }
        //     helper(arr);
        //     return result;
        // }

        // // PURE Recursion
        // function collectOddValues(arr){
        //     let result = [];
        //     if(arr.length === 0){
        //         return result;
        //     }   
        //     if((arr[0] % 2) !== 0){
        //         result.push(arr[0])
        //     }
        //     result = result.concat(collectOddValues(arr.slice(1)))
        //     return result;
        // }
        // console.log(collectOddValues([1,2,6,6,3,2,9,10,87,45,901,67]));

        // // NOTES - IMPORTANT
        // For arrays, use methods like slice, the spread operator, and concat that make copies of arrays so you do not mutate them
        // Remember that strings are immutable so you will need to use methods like slice, substr, or substring to make copies of strings
        // To make copies of objects use Object.assign, or the spread operator


        // // // EX - 27
        // function power(num, exponent){
        //     return Math.pow(num, exponent);
        // }

        // function power(base, exponent) {
        //     if (exponent === 0) {
        //         return 1;
        //     } else if (exponent < 0) {
        //         return 1 / power(base, -exponent);
        //     } else {
        //         return base * power(base, exponent - 1);
        //     }
        // }

        // function power(num, exponent){    
        //     if(exponent === 0) return 1;
        //     return num * power(num, exponent-1)
        // }

        // console.log(power(2,4));


        // // // EX - 28
        // function productOfArray(arr){
        //     if(arr.length === 0) return 1;
        //     return arr[0] * productOfArray(arr.slice(1));
        // }
        // console.log(productOfArray([1,2,3,10]));

        // // // EX - 29
        // function recursiveRange(num){
        //     if(num === 0) return 0;
        //     return num + recursiveRange(num-1);
        // }

        // function recursiveRange(n){
        //     return n/2*(2 + (n - 1) * 1);
        // }
        
        // console.log(recursiveRange(4));


        // // // EX - 30
        // function fib(num){
        //     if (num <= 2) return 1;
        //     let a = 0;
        //     let b = 1;
        //     let c = 0;
        //     for(let i = 2; i <= num; i++){
        //         c = a+b;
        //         a = b;
        //         b = c;
        //     }
        //     return c;
        // }

        // Better solution
        // function fib(n){
        //     if (n <= 2) return 1;
        //     return fib(n-1) + fib(n-2);
        // }
        // console.log(fib(3))


        // // // EX - 31
        // function reverse(str){
        //     if(str.length === 0){
        //         return str;
        //     }
        //     return reverse(str.substring(1)) + str.charAt(0)
        // }
        // console.log(reverse('hello'))


        // // // EX - 32
        // function isPalindrome(str) {
        //     if(str.length == 1) return true;
        //     if(str.length == 2) return str[0] == str[1];
           
        //     function helper(rcvStr){
        //         if(rcvStr.length === 0) return rcvStr;
        //         return helper(rcvStr.slice(1)) + rcvStr[0];
        //     }
        //     let newStr = helper(str);
        //     if(newStr == str){
        //         return true;
        //     }else{
        //         return false;
        //     }
        // };

        // Better solution
        //function isPalindrome(str){
        //     if(str.length === 1) return true;
        //     if(str.length === 2) return str[0] === str[1];
        //     if(str[0] === str.slice(-1)) return isPalindrome(str.slice(1,-1))
        //     return false;
        // }

        // console.log(isPalindrome('amanaplanacanalpanama'));

        // // // EX - 34     
        // function someRecursive(array, callBack){
        //     if(array.length === 0) return false;
            
        //     if(callBack(array[0])) return true;
            
        //     return someRecursive(array.slice(1), callBack)
        
        // }
        // console.log(someRecursive([1234], 'callBack'))


        // // // EX - 35
        // function flatten(oldArr){
        //     let str =  oldArr.toString();
        //     let array = JSON.parse("[" + str + "]");
        //     return array;
        // }

        // using recursion method solution from udemy
        // function flatten(oldArr){
        //     var newArr = []
        //         for(var i = 0; i < oldArr.length; i++){
        //             if(Array.isArray(oldArr[i])){
        //                 newArr = newArr.concat(flatten(oldArr[i]))
        //             } else {
        //                 newArr.push(oldArr[i])
        //             }
        //     } 
        //     return newArr;
        // }

        // console.log(flatten([[[[1], [[[2]]], [[[[[[[3]]]]]]]]]]));

        // // // EX - 36
        // function capitalizeWords (array) {
        //     let newArray = [];
        //     for(let i = 0; i<array.length; i++){
        //         newArray.push(array[i].charAt(0).toUpperCase() + array[i].substring(1));
        //     }
        //     return newArray;
        // }


        // use recursion function solution from udemy
        // function capitalizeWords (array) {
        //     if (array.length === 1) {
        //         let str = array[0];
        //         return [str[0].toUpperCase() + str.substring(1)];
        //     }
        //     let res = capitalizeWords(array.slice(0, -1));
        //     let str = array.slice(array.length-1)[0];
        //     res.push(str[0].toUpperCase() + str.substring(1));
        //     return res; 
        // }
        // console.log(capitalizeWords(['car','taco','banana']));


         // // // EX - 37
        // function nestedEvenSum () {
       
        // }


        // var obj1 = {
        //     outer: 2,
        //     obj: {
        //         inner: 2,
        //         otherObj: {
        //         superInner: 2,
        //         notANumber: true,
        //         alsoNotANumber: "yup"
        //         }
        //     }
        // }

        // var obj2 = {
        //     a: 2,
        //     b: {b: 2, bb: {b: 3, bb: {b: 2}}},
        //     c: {c: {c: 2}, cc: 'ball', ccc: 5},
        //     d: 1,
        //     e: {e: {e: 2}, ee: 'car'}
        // };

        // nestedEvenSum(obj1); // 6
        // nestedEvenSum(obj2); // 10
        
       



        // // Searching Algorithms
        // // Linear Search 
        // This function accepts an array and a value
        // Loop through the array and check if the current array element is equal to the value
        // If it is, return the index at which the element is found
        // If the value is never found, return -1

        // // // EX - 33
        // function linearSearch(array, value){
        //     if(array.length === 0) return -1
        //     if(array.length === 1){
        //         if(array[0] === value){
        //             return 0;
        //         }else{
        //             return -1;
        //         }
        //     }
        //     for(let i = 0; i < array.length ;i++){
        //         if(array[i] == value){ 
        //             return i;
        //         } 
        //     }
        //     return -1;
        // }

        // console.log(linearSearch([15], 15));


        // // Binary Search
        // Binary search is a much faster form of search
        // Rather than eliminating one element at a time, you can eliminate half of the remaining elements at a time
        // Binary search only works on sorted arrays!
        // This function accepts a sorted array and a value
        // Create a left pointer at the start of the array, and a right pointer at the end of the array
        // While the left pointer comes before the right pointer:
        // Create a pointer in the middle
        // If you find the value you want, return the index
        // If the value is too small, move the left pointer up
        // If the value is too large, move the right pointer down
        // If you never find the value, return -1

        // // // EX - 38
        // function binarySearch(arr, num){

        //     if(arr.length === 0) return -1;

        //     let left = 0;
        //     let right = arr.length - 1;

        //     // return Math.ceil((left+right)/2);
        //     while(left <= right){
        //         let middle = Math.floor((left+right)/2);
        //         if(arr[middle] === num){
        //             return middle;
        //         }else if(arr[middle] < num){
        //             left = middle + 1
        //         }else {
        //             right = middle - 1;
        //         }
        //     }
        //     return -1;

        // }

        // console.log(binarySearch([1,2,3,4,5],2)); // 1
        // console.log(binarySearch([1,2,3,4,5],3)); // 2
        // console.log(binarySearch([1,2,3,4,5],5)); // 4
        // console.log(binarySearch([1,2,3,4,5],6)); // -1
        // console.log(binarySearch([ 5, 6, 10, 13, 14, 18, 30, 34, 35, 37, 40, 44, 64, 79, 84, 86, 95, 96, 98, 99 ], 10)); // 2
        // console.log(binarySearch([ 5, 6, 10, 13, 14, 18, 30, 34, 35, 37, 40, 44, 64, 79, 84, 86, 95, 96, 98, 99 ], 95)); // 16
        // console.log(binarySearch([ 5, 6, 10, 13, 14, 18, 30, 34, 35, 37, 40, 44, 64, 79, 84, 86, 95, 96, 98, 99 ], 100)); // -1


        // // // EX - 39
        // function naiveSearch(long, short){
        //     // var count = 0;
        //     // for(var i = 0; i < long.length; i++){
        //     //     for(var j = 0; j < short.length; j++){
        //     //       if(short[j] !== long[i+j]) break;
        //     //       if(j === short.length - 1) count++;
        //     //     }
        //     // }
        //     // return count;

        //     // or
        //     return long.split(short).length - 1;
        // }

        // console.log(naiveSearch("lorie loled bceuicw lol", "lol"))



        // // Sorting Algorithms
        // Sorting is the process of rearranging the items in a collection (e.g. an array) so that the items are in some kind of order.

        // var numArray = [140000, 104, 99];
        // numArray.sort(function(a, b) {
        //     return a - b; // 99, 104, 140000
        //     // return b - a; //140000, 104, 99
        // });
        // // numArray.sort((a,b) =>  a-b ); // sort hand
        // console.log(numArray);



    











































    </script>
</body>
</html>
